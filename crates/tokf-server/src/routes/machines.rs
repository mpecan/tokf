use axum::{Json, extract::State, http::StatusCode};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::auth::token::AuthUser;
use crate::error::AppError;
use crate::state::AppState;

// ── Request / Response types ─────────────────────────────────────────────────

#[derive(Debug, Deserialize)]
pub struct RegisterMachineRequest {
    /// UUID v4 string generated by the client
    pub machine_id: String,
    pub hostname: String,
}

#[derive(Debug, Serialize)]
pub struct MachineResponse {
    pub machine_id: String,
    pub hostname: String,
    pub created_at: String,
    pub last_sync_at: Option<String>,
}

// ── Internal helpers ──────────────────────────────────────────────────────────

/// Row type returned by machine SELECT/INSERT/UPDATE queries.
type MachineRow = (
    Uuid,
    String,
    chrono::DateTime<chrono::Utc>,
    Option<chrono::DateTime<chrono::Utc>>,
);

fn row_to_response((id, hostname, created_at, last_sync_at): MachineRow) -> MachineResponse {
    MachineResponse {
        machine_id: id.to_string(),
        hostname,
        created_at: created_at.to_rfc3339(),
        last_sync_at: last_sync_at.map(|t| t.to_rfc3339()),
    }
}

/// Maximum number of machines a single user may register.
const MAX_MACHINES_PER_USER: i64 = 50;

/// Maximum allowed hostname length (matches FQDN length limit per RFC 1035).
const MAX_HOSTNAME_LEN: usize = 253;

fn validate_hostname(hostname: &str) -> Result<(), AppError> {
    if hostname.is_empty() {
        return Err(AppError::BadRequest(
            "hostname must not be empty".to_string(),
        ));
    }
    if hostname.len() > MAX_HOSTNAME_LEN {
        return Err(AppError::BadRequest(format!(
            "hostname must not exceed {MAX_HOSTNAME_LEN} characters"
        )));
    }
    Ok(())
}

// ── POST /api/machines ────────────────────────────────────────────────────────

/// Register (or update) a machine for the authenticated user.
///
/// Validates the client-supplied UUID and hostname, then:
/// - Returns `201 Created` when a new machine is registered.
/// - Returns `200 OK` when an existing machine's hostname is updated.
/// - Returns `409 Conflict` if the UUID is already registered by a different user.
/// - Returns `429 Too Many Requests` when the per-user limit is reached.
///
/// # Errors
///
/// - `400 Bad Request` if `machine_id` is not a valid UUID or hostname is invalid.
/// - `401 Unauthorized` if the bearer token is missing or invalid.
/// - `409 Conflict` if the UUID belongs to another user.
/// - `429 Too Many Requests` if the user has reached the machine limit.
/// - `500 Internal Server Error` on database failures.
pub async fn register_machine(
    auth: AuthUser,
    State(state): State<AppState>,
    Json(body): Json<RegisterMachineRequest>,
) -> Result<(StatusCode, Json<MachineResponse>), AppError> {
    let machine_uuid = Uuid::parse_str(&body.machine_id)
        .map_err(|_| AppError::BadRequest("machine_id is not a valid UUID".to_string()))?;

    validate_hostname(&body.hostname)?;

    // Check whether this UUID already exists and who owns it.
    let existing_owner: Option<i64> =
        sqlx::query_scalar("SELECT user_id FROM machines WHERE id = $1")
            .bind(machine_uuid)
            .fetch_optional(&state.db)
            .await?;

    let (status_code, row) = match existing_owner {
        Some(owner_id) if owner_id != auth.user_id => {
            return Err(AppError::Conflict(
                "machine ID is already registered by another user".to_string(),
            ));
        }
        Some(_) => {
            // Same user — update hostname and return 200.
            let row = sqlx::query_as::<_, MachineRow>(
                "UPDATE machines SET hostname = $1 WHERE id = $2
                 RETURNING id, hostname, created_at, last_sync_at",
            )
            .bind(&body.hostname)
            .bind(machine_uuid)
            .fetch_one(&state.db)
            .await?;
            (StatusCode::OK, row)
        }
        None => {
            // New machine — enforce per-user limit before inserting.
            let count: i64 = sqlx::query_scalar("SELECT COUNT(*) FROM machines WHERE user_id = $1")
                .bind(auth.user_id)
                .fetch_one(&state.db)
                .await?;

            if count >= MAX_MACHINES_PER_USER {
                return Err(AppError::RateLimited);
            }

            let row = sqlx::query_as::<_, MachineRow>(
                "INSERT INTO machines (id, user_id, hostname) VALUES ($1, $2, $3)
                 RETURNING id, hostname, created_at, last_sync_at",
            )
            .bind(machine_uuid)
            .bind(auth.user_id)
            .bind(&body.hostname)
            .fetch_one(&state.db)
            .await?;
            (StatusCode::CREATED, row)
        }
    };

    Ok((status_code, Json(row_to_response(row))))
}

// ── GET /api/machines ─────────────────────────────────────────────────────────

/// List all machines registered by the authenticated user.
///
/// Returns machines ordered by registration date (newest first).
///
/// # Errors
///
/// - `401 Unauthorized` if the bearer token is missing or invalid.
/// - `500 Internal Server Error` on database failures.
pub async fn list_machines(
    auth: AuthUser,
    State(state): State<AppState>,
) -> Result<(StatusCode, Json<Vec<MachineResponse>>), AppError> {
    let rows = sqlx::query_as::<_, MachineRow>(
        "SELECT id, hostname, created_at, last_sync_at
         FROM machines
         WHERE user_id = $1
         ORDER BY created_at DESC",
    )
    .bind(auth.user_id)
    .fetch_all(&state.db)
    .await?;

    let machines = rows.into_iter().map(row_to_response).collect();

    Ok((StatusCode::OK, Json(machines)))
}

// ── Tests ─────────────────────────────────────────────────────────────────────

#[cfg(test)]
#[allow(clippy::unwrap_used, clippy::expect_used)]
mod tests {
    use std::sync::Arc;

    use axum::{
        body::Body,
        http::{Request, StatusCode},
    };
    use http_body_util::BodyExt;
    use sqlx::PgPool;
    use tower::ServiceExt;

    use crate::auth::mock::NoOpGitHubClient;
    use crate::auth::token::{generate_token, hash_token};
    use crate::rate_limit::{PublishRateLimiter, SyncRateLimiter};
    use crate::state::AppState;
    use crate::storage::noop::NoOpStorageClient;

    fn make_state(pool: PgPool) -> AppState {
        AppState {
            db: pool,
            github: Arc::new(NoOpGitHubClient),
            storage: Arc::new(NoOpStorageClient),
            github_client_id: "test-client-id".to_string(),
            github_client_secret: "test-client-secret".to_string(),
            trust_proxy: false,
            public_url: "http://localhost:8080".to_string(),
            publish_rate_limiter: Arc::new(PublishRateLimiter::new(100, 3600)),
            search_rate_limiter: Arc::new(PublishRateLimiter::new(1000, 3600)),
            sync_rate_limiter: Arc::new(SyncRateLimiter::new(100, 3600)),
        }
    }

    /// Insert a test user and return `(user_id, bearer_token)`.
    async fn insert_test_user(pool: &PgPool, username: &str) -> (i64, String) {
        let user_id: i64 = sqlx::query_scalar(
            "INSERT INTO users (github_id, username, avatar_url, profile_url)
             VALUES ($1, $2, $3, $4)
             RETURNING id",
        )
        .bind(rand_i64())
        .bind(username)
        .bind("https://avatars.example.com/test")
        .bind("https://github.com/test")
        .fetch_one(pool)
        .await
        .expect("failed to insert test user");

        let token = generate_token();
        let token_hash = hash_token(&token);
        sqlx::query(
            "INSERT INTO auth_tokens (user_id, token_hash, expires_at)
             VALUES ($1, $2, NOW() + INTERVAL '1 hour')",
        )
        .bind(user_id)
        .bind(&token_hash)
        .execute(pool)
        .await
        .expect("failed to insert test token");

        (user_id, token)
    }

    fn rand_i64() -> i64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        i64::from(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .subsec_nanos(),
        ) + i64::from(rand::random::<i32>())
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_creates_record(pool: PgPool) {
        let (_, token) = insert_test_user(&pool, "alice").await;
        let app = crate::routes::create_router(make_state(pool.clone()));

        let machine_id = "550e8400-e29b-41d4-a716-446655440000";
        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(format!(
                        r#"{{"machine_id":"{machine_id}","hostname":"test-host"}}"#
                    )))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::CREATED);
        let body = resp.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
        assert_eq!(json["machine_id"], machine_id);
        assert_eq!(json["hostname"], "test-host");
        assert!(json["created_at"].is_string());
        assert!(json["last_sync_at"].is_null());
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_updates_hostname_returns_200(pool: PgPool) {
        let (_, token) = insert_test_user(&pool, "alice_upsert").await;
        let machine_id = "660e8400-e29b-41d4-a716-446655440000";

        // First registration → 201
        let app = crate::routes::create_router(make_state(pool.clone()));
        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(format!(
                        r#"{{"machine_id":"{machine_id}","hostname":"old-host"}}"#
                    )))
                    .unwrap(),
            )
            .await
            .unwrap();
        assert_eq!(resp.status(), StatusCode::CREATED);

        // Re-register with new hostname → 200
        let app = crate::routes::create_router(make_state(pool.clone()));
        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(format!(
                        r#"{{"machine_id":"{machine_id}","hostname":"new-host"}}"#
                    )))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::OK);
        let body = resp.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
        assert_eq!(json["hostname"], "new-host");
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_rejects_cross_user_uuid_conflict(pool: PgPool) {
        let (_, token_a) = insert_test_user(&pool, "user_conflict_a").await;
        let (_, token_b) = insert_test_user(&pool, "user_conflict_b").await;
        let machine_id = "880e8400-e29b-41d4-a716-446655440000";

        // user_a registers the machine
        let app = crate::routes::create_router(make_state(pool.clone()));
        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token_a}"))
                    .header("content-type", "application/json")
                    .body(Body::from(format!(
                        r#"{{"machine_id":"{machine_id}","hostname":"host-a"}}"#
                    )))
                    .unwrap(),
            )
            .await
            .unwrap();
        assert_eq!(resp.status(), StatusCode::CREATED);

        // user_b tries to claim the same UUID → 409
        let app = crate::routes::create_router(make_state(pool));
        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token_b}"))
                    .header("content-type", "application/json")
                    .body(Body::from(format!(
                        r#"{{"machine_id":"{machine_id}","hostname":"host-b"}}"#
                    )))
                    .unwrap(),
            )
            .await
            .unwrap();
        assert_eq!(resp.status(), StatusCode::CONFLICT);
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_rejects_invalid_uuid(pool: PgPool) {
        let (_, token) = insert_test_user(&pool, "alice_bad_uuid").await;
        let app = crate::routes::create_router(make_state(pool));

        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(
                        r#"{"machine_id":"not-a-uuid","hostname":"test-host"}"#,
                    ))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_rejects_empty_machine_id(pool: PgPool) {
        let (_, token) = insert_test_user(&pool, "alice_empty_id").await;
        let app = crate::routes::create_router(make_state(pool));

        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(r#"{"machine_id":"","hostname":"test-host"}"#))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_rejects_empty_hostname(pool: PgPool) {
        let (_, token) = insert_test_user(&pool, "alice_empty_host").await;
        let app = crate::routes::create_router(make_state(pool));

        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(
                        r#"{"machine_id":"550e8400-e29b-41d4-a716-446655440000","hostname":""}"#,
                    ))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::BAD_REQUEST);
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_rejects_missing_fields(pool: PgPool) {
        let (_, token) = insert_test_user(&pool, "alice_missing").await;
        let app = crate::routes::create_router(make_state(pool));

        // Missing machine_id field entirely → 422
        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(r#"{"hostname":"test-host"}"#))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::UNPROCESSABLE_ENTITY);
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn register_machine_enforces_per_user_limit(pool: PgPool) {
        let (_, token) = insert_test_user(&pool, "alice_limit").await;

        // Register MAX_MACHINES_PER_USER (50) machines
        for i in 0..50_u8 {
            // Manufacture 50 distinct UUIDs by varying the first byte
            let machine_id = format!("{i:02x}0e8400-e29b-41d4-a716-446655440000");
            let app = crate::routes::create_router(make_state(pool.clone()));
            let resp = app
                .oneshot(
                    Request::builder()
                        .method("POST")
                        .uri("/api/machines")
                        .header("authorization", format!("Bearer {token}"))
                        .header("content-type", "application/json")
                        .body(Body::from(format!(
                            r#"{{"machine_id":"{machine_id}","hostname":"host-{i}"}}"#
                        )))
                        .unwrap(),
                )
                .await
                .unwrap();
            assert_eq!(
                resp.status(),
                StatusCode::CREATED,
                "machine {i} should be created"
            );
        }

        // The 51st machine should be rejected with 429
        let app = crate::routes::create_router(make_state(pool));
        let resp = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token}"))
                    .header("content-type", "application/json")
                    .body(Body::from(
                        r#"{"machine_id":"ff0e8400-e29b-41d4-a716-446655440000","hostname":"one-too-many"}"#,
                    ))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::TOO_MANY_REQUESTS);
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn list_machines_only_returns_own_machines(pool: PgPool) {
        let (_, token_a) = insert_test_user(&pool, "user_a").await;
        let (_, token_b) = insert_test_user(&pool, "user_b").await;

        // Register a machine as user_a
        let app = crate::routes::create_router(make_state(pool.clone()));
        app.oneshot(
            Request::builder()
                .method("POST")
                .uri("/api/machines")
                .header("authorization", format!("Bearer {token_a}"))
                .header("content-type", "application/json")
                .body(Body::from(
                    r#"{"machine_id":"770e8400-e29b-41d4-a716-446655440000","hostname":"user-a-host"}"#,
                ))
                .unwrap(),
        )
        .await
        .unwrap();

        // user_b should see an empty list
        let app = crate::routes::create_router(make_state(pool));
        let resp = app
            .oneshot(
                Request::builder()
                    .method("GET")
                    .uri("/api/machines")
                    .header("authorization", format!("Bearer {token_b}"))
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::OK);
        let body = resp.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
        assert_eq!(
            json.as_array().unwrap().len(),
            0,
            "user_b should see no machines"
        );
    }

    #[crdb_test_macro::crdb_test(migrations = "./migrations")]
    async fn list_machines_requires_auth(pool: PgPool) {
        let app = crate::routes::create_router(make_state(pool));
        let resp = app
            .oneshot(
                Request::builder()
                    .method("GET")
                    .uri("/api/machines")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
    }
}
