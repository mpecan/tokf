# examples.toml — Annotated TOML showing every step type in one place
#
# This is a reference document, not a real filter. It demonstrates syntax for
# every field and step type. Real filters use a subset of these fields.
#
# Processing order (fixed):
#   1. match_output (short-circuit)
#   2. [[replace]] (per-line transforms)
#   3. skip / keep (line filtering)
#   4. dedup / dedup_window
#   5. lua_script (escape hatch)
#   6. [[section]] OR [parse]  ← mutually exclusive
#   7. [[chunk]] (block-based structured extraction, runs alongside sections)
#   8. [on_success] / [on_failure] (exit-code branch)
#   9. [fallback] (last resort)

# ─── TOP-LEVEL FIELDS ────────────────────────────────────────────────────────

# command: string or array. Supports * wildcard.
command = "example-tool run"
# command = ["example-tool run", "ex run"]        # array form
# command = "example-tool *"                       # wildcard form

# run: override the actual command executed.
# {args} = arguments the user passed after the matched command prefix.
run = "example-tool run --machine-readable {args}"

# ─── STEP 1: match_output ────────────────────────────────────────────────────

# Whole-output substring checks. Evaluated FIRST. Short-circuits on match.
# {line_containing} = the first line that contains the 'contains' substring.
match_output = [
  { contains = "nothing to do", output = "ok (nothing to do)" },
  { contains = "fatal:", output = "Fatal: {line_containing}" },
  { contains = "auth failed", output = "✗ authentication failed" },
]

# ─── STEP 2: [[replace]] ─────────────────────────────────────────────────────

# Per-line regex transforms. Applied in array order, before skip/keep.
# {0} = full match, {1}, {2}, ... = capture groups.
# Lines that don't match pass through unchanged.

[[replace]]
# Reformat verbose progress lines: "  Compiling foo v1.2.3 (/path)" → "compiling foo@1.2.3"
pattern = '^\\s+Compiling (\\S+) v(\\S+)'
output = "compiling {1}@{2}"

[[replace]]
# Strip ANSI color codes
pattern = '\\x1b\\[[0-9;]*m'
output = ""

[[replace]]
# Reformat table rows: extract columns 1, 3, 4
# Raw strings ('...') avoid double-backslash escaping
pattern = '^(\\S+)\\s+\\S+\\s+(\\S+)\\s+(\\S+)'
output = "{1}: {2} → {3}"

# ─── STEP 3: skip / keep ─────────────────────────────────────────────────────

# skip: drop lines matching any regex. Applied after [[replace]].
skip = [
  "^\\s*$",               # blank lines
  "^\\s*Downloading ",    # download progress
  "^\\s*Downloaded ",
  "^\\s*Locking ",
  "^\\[=+>\\s*\\]",       # progress bars
]

# keep: retain ONLY lines matching any regex. Inverse of skip.
# Empty array = keep all. Non-empty = allow-list.
# When both skip and keep are set: must not match skip AND must match keep.
keep = ["^error", "^warning", "^FAILED", "^ok"]

# ─── STEP 4: dedup / dedup_window ────────────────────────────────────────────

# dedup: collapse consecutive identical lines (like `uniq`)
dedup = true

# dedup_window: dedup within a sliding window of N lines
dedup_window = 5

# ─── STEP 5: lua_script ──────────────────────────────────────────────────────

# Luau escape hatch. Runs after dedup, before [[section]]/[parse].
# Globals: output (string), exit_code (integer), args (table of strings)
# Return string → replaces output, skips remaining pipeline
# Return nil → fall through to [[section]]/[parse]/[on_success]/[on_failure]
# Sandbox: io, os, package are blocked. math, string, table, utf8 available.

[lua_script]
lang = "luau"
source = '''
-- Count occurrences of a pattern
local count = 0
for _ in output:gmatch("FAILED") do
    count = count + 1
end

-- Use args to customize behavior
local verbose = false
for _, arg in ipairs(args) do
    if arg == "--verbose" then verbose = true end
end

if exit_code == 0 then
    if verbose then
        return "passed ✓ (exit 0)\n" .. output
    else
        return nil  -- fall through to [on_success]
    end
else
    return count .. " FAILED test(s)\n" .. output
end
'''

# ─── STEP 6a: [[section]] ────────────────────────────────────────────────────
#
# [[section]] and [parse] are MUTUALLY EXCLUSIVE. Use one or the other.
# Comment out one block to use the other.
#
# State-machine collector. Routes lines into named variables.
# Variables accessed in templates:
#   {name}           → full collected text (lines joined with \n)
#   {name.lines}     → collection of individual lines
#   {name.blocks}    → collection of blocks split by split_on
#   {name.count}     → number of blocks (or lines if no split_on)

[[section]]
name = "errors"
# enter: start collecting when this matches
enter = "^=+ ERRORS =+$"
# exit: stop collecting when this matches (after entering)
exit = "^=+ END =+$"
# split_on: split collected content into blocks on lines matching this
split_on = "^-+ "
collect_as = "error_blocks"

[[section]]
name = "warnings"
# match: collect any line matching this (no enter/exit state machine)
match = "^warning\\["
collect_as = "warning_lines"

[[section]]
name = "summary"
match = "^SUMMARY:"
collect_as = "summary_lines"

# ─── STEP 6b: [[chunk]] ──────────────────────────────────────────────────────
#
# Block-based structured extraction. Splits raw output into repeating blocks,
# extracts data per-block, and produces named structured collections.
# Runs on raw output (alongside sections), not affected by skip/keep.

# [[chunk]]
# split_on = "^\\s*Running "        # regex marking the start of each chunk
# include_split_line = true          # include the splitting line in each chunk
# collect_as = "suites_detail"       # name for the structured collection
# group_by = "crate_name"            # merge chunks sharing this field value
# children_as = "children"           # preserve original items as nested collection
#
# [chunk.extract]
# pattern = 'unittests.+deps/([\w_-]+)-'   # extract from header line
# as = "crate_name"                  # field name for the extracted value
# carry_forward = true               # inherit from previous chunk when unmatched
#
# [[chunk.body_extract]]
# pattern = 'Running\s+(.+?)\s+\('  # extract from body lines (first match wins)
# as = "suite_name"
#
# [[chunk.aggregate]]
# pattern = '(\d+) passed'          # per-chunk aggregation
# sum = "passed"                     # sum the captured number
#
# [[chunk.aggregate]]
# pattern = '^test result:'
# count_as = "suite_count"           # count matching lines
#
# Structured collections in templates:
#   {suites_detail | each: "  {crate_name}: {passed}" | join: "\n"}
# Tree output (when children_as is set):
#   {suites_detail | each: "  {crate_name}\n{children | each: \"    {suite_name}\" | join: \"\\n\"}" | join: "\n"}

# ─── STEP 6c: [parse] ────────────────────────────────────────────────────────
#
# (Commented out — cannot use both [[section]] and [parse])
#
# Declarative structured parser for table-like output.
# branch: extract a value from a specific line
# [parse.group]: group remaining lines by a key pattern

# [parse]
# branch = { line = 1, pattern = '^Status: (\S+)', output = "{1}" }
#
# [parse.group]
# key = { pattern = '^(\w+)\s', output = "{1}" }
# labels = { "ok" = "succeeded", "fail" = "failed", "skip" = "skipped" }
#
# [output]
# format = "Status: {branch}\n{group_counts}"
# group_counts_format = "  {label}: {count}"
# empty = "no results"

# ─── STEP 8: [on_success] ────────────────────────────────────────────────────

[on_success]
# output: template. {output} = filtered output. Section variables also available.
# head/tail: trim lines
# skip: additional per-branch filtering
# extract: find first match, render template with capture groups
# aggregate: reduce section lines into numeric summaries

# Keep first 30 lines of filtered output
head = 30

# Additional skip within this branch
skip = ["^\\s*$", "^debug:"]

# extract: find first line matching pattern, render output
extract = { pattern = '(\\d+)/(\\d+) passed', output = "✓ {1} of {2} tests passed" }

# aggregate (singular): sum numbers extracted from section lines
aggregate = { from = "summary_lines", pattern = '(\\d+) passed', sum = "passed", count_as = "suites" }

# aggregates (plural) — use [[on_success.aggregates]] for multiple rules:
# [[on_success.aggregates]]
# from = "summary_lines"
# pattern = '(\\d+) passed'
# sum = "passed"
# count_as = "suites"
#
# [[on_success.aggregates]]
# from = "summary_lines"
# pattern = '(\\d+) failed'
# sum = "failed"
#
# Both singular `aggregate` and plural `aggregates` can be used together.

# output template: has access to all [[section]] and [[chunk]] variables
output = """
✓ {passed} passed across {suites} suites
Warnings: {warning_lines.count}
{warning_lines | join: "\\n" | truncate: 500}"""

# ─── STEP 8b: [on_failure] ───────────────────────────────────────────────────

[on_failure]
# tail: keep last N lines of filtered output
tail = 20

# output with complex pipe chains
output = """
FAILED — {error_blocks.count} error(s):
══════════════════════════════════════
{error_blocks | each: "{index}. {value | lines | keep: \"^E \" | join: \"\\n\"}" | join: "\\n---\\n"}

Summary:
{summary_lines | join: "\\n"}

Warnings ({warning_lines.count}):
{warning_lines | each: "{index}. {value | truncate: 120}" | join: "\\n"}"""

# ─── STEP 9: [fallback] ──────────────────────────────────────────────────────

# Emitted when neither [on_success] nor [on_failure] produced output.
# Use as a safety net for complex filters.

[fallback]
tail = 5

# ─── TEMPLATE PIPE REFERENCE ─────────────────────────────────────────────────
#
# Pipe chains: {var | pipe | pipe: "arg"}
#
# lines         Str → Collection      Split on \n
# join: "sep"   Collection → Str      Join with separator
# each: "tmpl"  Collection → Coll     Map; {value} = item, {index} = 1-based
# keep: "re"    Collection → Coll     Retain items matching regex
# where: "re"   Collection → Coll     Alias for keep:
# truncate: N   Str → Str            Truncate to N chars, append …
#
# Examples:
#
# Filter to error lines and join:
#   {output | lines | keep: "^error" | join: "\n"}
#
# Number and truncate blocks:
#   {blocks | each: "{index}. {value | truncate: 200}" | join: "\n"}
#
# Nested pipes inside each (requires escaped quotes):
#   {blocks | each: "{value | lines | keep: \"^E \"}" | join: "\n---\n"}
