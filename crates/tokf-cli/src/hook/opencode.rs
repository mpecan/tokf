use std::path::{Path, PathBuf};

use anyhow::Context;

// R1: Use export default object literal (not a function returning one).
// R7: Add 5000ms timeout to Bun.spawnSync.
// R8: Check proc.stdout for null before decoding.
// R9: Log errors in catch block with [tokf] prefix.
const PLUGIN_TEMPLATE: &str = r#"// tokf-filter plugin for OpenCode
// Generated by: tokf hook install --tool opencode
// Docs: https://github.com/mpecan/tokf
const TOKF_BIN = "{{TOKF_PATH}}";
export default {
  "tool.execute.before": async (
    input: { tool: string },
    output: { args: { command?: string } }
  ): Promise<void> => {
    if (input.tool !== "bash" || !output.args.command) return;
    try {
      const proc = Bun.spawnSync([TOKF_BIN, "rewrite", output.args.command], {
        timeout: 5000,
      });
      if (proc.exitCode === 0 && proc.stdout) {
        const rewritten = new TextDecoder().decode(proc.stdout).trim();
        if (rewritten && rewritten !== output.args.command) {
          output.args.command = rewritten;
        }
      }
    } catch (err) {
      // passthrough â€” never block a command
      console.error("[tokf] plugin error:", err instanceof Error ? err.message : String(err));
    }
  },
};
"#;

/// Install the `OpenCode` plugin.
///
/// # Errors
///
/// Returns an error if the plugin directory cannot be created or the plugin file cannot be written.
pub fn install(global: bool) -> anyhow::Result<()> {
    let plugin_dir = if global {
        global_plugin_dir()?
    } else {
        PathBuf::from(".opencode/plugins")
    };
    install_to(&plugin_dir)
}

pub(crate) fn install_to(plugin_dir: &Path) -> anyhow::Result<()> {
    write_plugin_file(plugin_dir)?;
    // R5: Standardize eprintln prefix to [tokf]
    eprintln!(
        "[tokf] OpenCode plugin installed to {}",
        plugin_dir.join("tokf.ts").display()
    );
    eprintln!("[tokf] OpenCode will auto-load the plugin on next start.");
    Ok(())
}

fn global_plugin_dir() -> anyhow::Result<PathBuf> {
    let home = dirs::home_dir().context("could not determine home directory")?;
    Ok(home.join(".config/opencode/plugins"))
}

// R10: Extract escaping logic into a small helper for testability.
fn escape_for_js_string(s: &str) -> anyhow::Result<String> {
    // serde_json::to_string gives us a JSON string with surrounding quotes; strip them.
    let json = serde_json::to_string(s).context("failed to serialize tokf path")?;
    // Strip surrounding quotes that to_string adds.
    Ok(json[1..json.len() - 1].to_string())
}

fn write_plugin_file(plugin_dir: &Path) -> anyhow::Result<()> {
    std::fs::create_dir_all(plugin_dir)
        .with_context(|| format!("failed to create plugin dir: {}", plugin_dir.display()))?;

    let tokf_path = std::env::current_exe().context("could not determine tokf executable path")?;
    let tokf_path_str = tokf_path.to_string_lossy();
    // R4: Use serde_json for proper JSON string escaping instead of manual replacement.
    let escaped = escape_for_js_string(tokf_path_str.as_ref())?;
    let content = PLUGIN_TEMPLATE.replace("{{TOKF_PATH}}", &escaped);

    let plugin_file = plugin_dir.join("tokf.ts");
    std::fs::write(&plugin_file, &content)
        .with_context(|| format!("failed to write plugin file: {}", plugin_file.display()))?;

    Ok(())
}

#[cfg(test)]
#[allow(clippy::unwrap_used, clippy::expect_used)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn install_to_creates_plugin_file() {
        let dir = TempDir::new().unwrap();
        let plugin_dir = dir.path().join("plugins");

        install_to(&plugin_dir).unwrap();

        assert!(plugin_dir.join("tokf.ts").exists());
    }

    #[test]
    fn install_to_is_idempotent() {
        let dir = TempDir::new().unwrap();
        let plugin_dir = dir.path().join("plugins");

        install_to(&plugin_dir).unwrap();
        install_to(&plugin_dir).unwrap();

        // Only one file exists, no errors
        let entries: Vec<_> = std::fs::read_dir(&plugin_dir).unwrap().collect();
        assert_eq!(entries.len(), 1);
    }

    #[test]
    fn write_plugin_embeds_tokf_path() {
        let dir = TempDir::new().unwrap();
        let plugin_dir = dir.path().join("plugins");

        write_plugin_file(&plugin_dir).unwrap();

        let content = std::fs::read_to_string(plugin_dir.join("tokf.ts")).unwrap();
        // Should not contain the template placeholder
        assert!(!content.contains("{{TOKF_PATH}}"));
        // Should contain something that looks like an executable path
        assert!(content.contains("const TOKF_BIN"));
    }

    #[test]
    fn write_plugin_rewrites_bash_tool_name() {
        let dir = TempDir::new().unwrap();
        let plugin_dir = dir.path().join("plugins");

        write_plugin_file(&plugin_dir).unwrap();

        let content = std::fs::read_to_string(plugin_dir.join("tokf.ts")).unwrap();
        assert!(content.contains(r#"input.tool !== "bash""#));
    }

    // R1: Verify the plugin uses export default object literal, not a function.
    #[test]
    fn plugin_template_uses_object_export() {
        assert!(PLUGIN_TEMPLATE.contains("export default {"));
        assert!(!PLUGIN_TEMPLATE.contains("export default async function"));
    }

    // R7: Verify timeout is present.
    #[test]
    fn plugin_template_has_timeout() {
        assert!(PLUGIN_TEMPLATE.contains("timeout: 5000"));
    }

    // R8: Verify stdout null check is present.
    #[test]
    fn plugin_template_checks_stdout_null() {
        assert!(PLUGIN_TEMPLATE.contains("proc.stdout"));
    }

    // R9: Verify error logging is present in catch block.
    #[test]
    fn plugin_template_logs_errors() {
        assert!(PLUGIN_TEMPLATE.contains("console.error"));
        assert!(PLUGIN_TEMPLATE.contains("[tokf] plugin error:"));
    }

    // R10: Test the path escaping helper handles special characters.
    #[test]
    fn escape_for_js_string_handles_special_chars() {
        // Test that backslashes get escaped
        assert!(
            escape_for_js_string("C:\\Users\\foo\\tokf")
                .unwrap()
                .contains("\\\\")
        );
        // Test that quotes are escaped as \" (i.e. the result contains \" not a bare ").
        // serde_json produces the JS-safe escape sequence.
        let escaped = escape_for_js_string("path\"with\"quotes").unwrap();
        assert!(
            escaped.contains("\\\""),
            "quotes should be backslash-escaped"
        );
        // The result must be safe to embed inside a JS double-quoted string:
        // it should not contain an unescaped double quote (any " must be preceded by \).
        let unescaped_quote = escaped
            .chars()
            .zip(std::iter::once(' ').chain(escaped.chars()))
            .any(|(ch, prev)| ch == '"' && prev != '\\');
        assert!(!unescaped_quote, "must not contain unescaped double quote");
    }

    // R10: Verify no placeholder remains after write.
    #[test]
    fn write_plugin_no_placeholder_remains() {
        let dir = TempDir::new().unwrap();
        let plugin_dir = dir.path().join("plugins");

        write_plugin_file(&plugin_dir).unwrap();

        let content = std::fs::read_to_string(plugin_dir.join("tokf.ts")).unwrap();
        assert!(!content.contains("{{TOKF_PATH}}"));
        assert!(content.contains("const TOKF_BIN"));
    }
}
